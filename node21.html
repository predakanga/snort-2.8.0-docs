<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2021.2 (Released July 1, 2021) -->
<HTML lang="en">
<HEAD>
<TITLE>3.5 Payload Detection Rule Options</TITLE>
<META NAME="description" CONTENT="3.5 Payload Detection Rule Options">
<META NAME="keywords" CONTENT="snort_manual">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2021.2">

<LINK REL="STYLESHEET" HREF="snort_manual.css">

<LINK REL="next" HREF="node22.html">
<LINK REL="previous" HREF="node20.html">
<LINK REL="next" HREF="node22.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node22.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node16.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node20.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html621"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node22.html">3.6 Non-Payload Detection Rule Options</A>
<B> Up:</B> <A
 HREF="node16.html">3. Writing Snort Rules: How</A>
<B> Previous:</B> <A
 HREF="node20.html">3.4 General Rule Options</A>
 &nbsp; <B>  <A ID="tex2html622"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A ID="tex2html623"
  HREF="node21.html#SECTION00451000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> content</A>
<UL>
<LI><A ID="tex2html624"
  HREF="node21.html#SECTION00451100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
<LI><A ID="tex2html625"
  HREF="node21.html#SECTION00451200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
<LI><A ID="tex2html626"
  HREF="node21.html#SECTION00451300000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Changing content behavior</A>
</UL>
<BR>
<LI><A ID="tex2html627"
  HREF="node21.html#SECTION00452000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> nocase</A>
<UL>
<LI><A ID="tex2html628"
  HREF="node21.html#SECTION00452100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
<LI><A ID="tex2html629"
  HREF="node21.html#SECTION00452200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</UL>
<BR>
<LI><A ID="tex2html630"
  HREF="node21.html#SECTION00453000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> rawbytes </A>
<UL>
<LI><A ID="tex2html631"
  HREF="node21.html#SECTION00453100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> format</A>
<LI><A ID="tex2html632"
  HREF="node21.html#SECTION00453200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</UL>
<BR>
<LI><A ID="tex2html633"
  HREF="node21.html#SECTION00454000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> depth</A>
<UL>
<LI><A ID="tex2html634"
  HREF="node21.html#SECTION00454100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</UL>
<BR>
<LI><A ID="tex2html635"
  HREF="node21.html#SECTION00455000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> offset</A>
<UL>
<LI><A ID="tex2html636"
  HREF="node21.html#SECTION00455100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</UL>
<BR>
<LI><A ID="tex2html637"
  HREF="node21.html#SECTION00456000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> distance</A>
<UL>
<LI><A ID="tex2html638"
  HREF="node21.html#SECTION00456100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
<LI><A ID="tex2html639"
  HREF="node21.html#SECTION00456200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</UL>
<BR>
<LI><A ID="tex2html640"
  HREF="node21.html#SECTION00457000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> within</A>
<UL>
<LI><A ID="tex2html641"
  HREF="node21.html#SECTION00457100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
<LI><A ID="tex2html642"
  HREF="node21.html#SECTION00457200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> Examples</A>
</UL>
<BR>
<LI><A ID="tex2html643"
  HREF="node21.html#SECTION00458000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> http_client_body</A>
<UL>
<LI><A ID="tex2html644"
  HREF="node21.html#SECTION00458100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
<LI><A ID="tex2html645"
  HREF="node21.html#SECTION00458200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">2</SPAN> Examples</A>
</UL>
<BR>
<LI><A ID="tex2html646"
  HREF="node21.html#SECTION00459000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> http_uri</A>
<UL>
<LI><A ID="tex2html647"
  HREF="node21.html#SECTION00459100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
<LI><A ID="tex2html648"
  HREF="node21.html#SECTION00459200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">2</SPAN> Examples</A>
</UL>
<BR>
<LI><A ID="tex2html649"
  HREF="node21.html#SECTION004510000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> uricontent</A>
<UL>
<LI><A ID="tex2html650"
  HREF="node21.html#SECTION004510100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</UL>
<BR>
<LI><A ID="tex2html651"
  HREF="node21.html#SECTION004511000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> urilen</A>
<UL>
<LI><A ID="tex2html652"
  HREF="node21.html#SECTION004511100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</UL>
<BR>
<LI><A ID="tex2html653"
  HREF="node21.html#SECTION004512000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> isdataat</A>
<UL>
<LI><A ID="tex2html654"
  HREF="node21.html#SECTION004512100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
<LI><A ID="tex2html655"
  HREF="node21.html#SECTION004512200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</UL>
<BR>
<LI><A ID="tex2html656"
  HREF="node21.html#SECTION004513000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> pcre </A>
<UL>
<LI><A ID="tex2html657"
  HREF="node21.html#SECTION004513100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
<LI><A ID="tex2html658"
  HREF="node21.html#SECTION004513200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</UL>
<BR>
<LI><A ID="tex2html659"
  HREF="node21.html#SECTION004514000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> byte_test</A>
<UL>
<LI><A ID="tex2html660"
  HREF="node21.html#SECTION004514100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</UL>
<BR>
<LI><A ID="tex2html661"
  HREF="node21.html#SECTION004515000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> byte_jump</A>
<UL>
<LI><A ID="tex2html662"
  HREF="node21.html#SECTION004515100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</UL>
<BR>
<LI><A ID="tex2html663"
  HREF="node21.html#SECTION004516000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> ftpbounce</A>
<UL>
<LI><A ID="tex2html664"
  HREF="node21.html#SECTION004516100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
<LI><A ID="tex2html665"
  HREF="node21.html#SECTION004516200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</UL>
<BR>
<LI><A ID="tex2html666"
  HREF="node21.html#SECTION004517000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN> asn1</A>
<UL>
<LI><A ID="tex2html667"
  HREF="node21.html#SECTION004517100000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
<LI><A ID="tex2html668"
  HREF="node21.html#SECTION004517200000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN> Examples</A>
</UL>
<BR>
<LI><A ID="tex2html669"
  HREF="node21.html#SECTION004518000000000000000"><SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">18</SPAN> Payload Detection Quick Reference</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H1><A ID="SECTION00450000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN> Payload Detection Rule Options</A>
</H1>

<H2><A ID="SECTION00451000000000000000"></A><A ID="sub:content"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> content
</H2>

<P>
The content keyword is one of the more important features of Snort.
It allows the user to set rules that search for specific content in
the packet payload and trigger response based on that data. Whenever
a content option pattern match is performed, the Boyer-Moore pattern
match function is called and the (rather computationally expensive)
test is performed against the packet contents. If data exactly matching
the argument data string is contained anywhere within the packet's
payload, the test is successful and the remainder of the rule option
tests are performed. Be aware that this test is case sensitive.

<P>
The option data for the content keyword is somewhat complex; it can
contain mixed text and binary data. The binary data is generally enclosed
within the pipe (<SPAN CLASS="MATH"><IMG
 STYLE="height: 2.78ex; vertical-align: -0.70ex; " SRC="img5.svg"
 ALT="$\vert$"></SPAN>) character and represented
as bytecode. Bytecode represents binary data as hexadecimal numbers
and is a good shorthand method for describing complex binary data.
Figure <A HREF="#mixed_content_example"><IMG  ALT="[*]" SRC="crossref.png"></A> contains an example of mixed text
and binary data in a Snort rule. 

<P>
Note that multiple content rules can be specified in one rule. This
allows rules to be tailored for less false positives. 

<P>
If the rule is preceded by a <SPAN  CLASS="texttt">!</SPAN>, the alert will be triggered
on packets that do not contain this content. This is useful when writing
rules that want to alert on packets that do not match a certain pattern

<P>

        
        <p><table border="1"><tr><td><b>
        Note:&nbsp;&nbsp;</b>
Also note that the following characters must be escaped inside a content
rule:

<P>
<PRE>
: ; \ "
</PRE>
        
        </b></td></tr></table></p>

<P>

<H3><A ID="SECTION00451100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
content: [!] "&lt;content string&gt;";
</PRE>

<P>

<H3><A ID="SECTION00451200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</H3>

<P>

<DIV class="CENTER"><A ID="mixed_content_example"></A><A ID="3280"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
Mixed Binary Bytecode and Text in a 'content' keyword</CAPTION>
<TR><TD><IMG
 STYLE="height: 6.30ex; " SRC="img50.svg"
 ALT="\begin{figure}\begin{verbatim}alert tcp any any -&gt; any 139 (content:''\vert 5c...
...t0\vert I\vert0\vert P\vert0\vert E\vert0 5c\vert'';)\end{verbatim}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<DIV class="CENTER"><A ID="content_negation_example"></A><A ID="3281"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
Negation Example</CAPTION>
<TR><TD><IMG
 STYLE="height: 6.30ex; " SRC="img51.svg"
 ALT="\begin{figure}\begin{verbatim}alert tcp any any -&gt; any 80 (content:!''GET'';)\end{verbatim}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

        
        <p><table border="1"><tr><td><b>
        Note:&nbsp;&nbsp;</b>
A <SPAN  CLASS="texttt">!</SPAN> modifier negates the results of the entire content search,
modifiers included.  For example, if using <SPAN  CLASS="texttt">content:!"A"; within:50;</SPAN>
and there are only 5 bytes of payload and there is no "A" in those 5 bytes,
the result will return a match.  If there must be 50 bytes for a valid
match, use <SPAN  CLASS="texttt">isdataat</SPAN> as a pre-cursor to the content.
        
        </b></td></tr></table></p>

<P>

<H3><A ID="SECTION00451300000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN>.<SPAN CLASS="arabic">3</SPAN> Changing content behavior</A>
</H3>

<P>
The <SPAN  CLASS="texttt">content</SPAN> keyword has a number of modifier keywords.  The modifier keywords change 
how the previously specified content works.  These modifier keywords are:

<P>
<DIV class="CENTER">
<A ID="3283"></A>
<TABLE class="PAD  BORDER" style="">
<CAPTION><STRONG>Table:</STRONG>
Content Modifiers </CAPTION>
<TR><TD CLASS="LEFT TOP"  WIDTH=92>Modifier</TD>
<TD CLASS="LEFT TOP"  WIDTH=92>Section</TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92>nocase</TD>
<TD CLASS="LEFT TOP"  WIDTH=92><A HREF="#sub:nocase"><IMG  ALT="[*]" SRC="crossref.png"></A></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92>rawbytes</TD>
<TD CLASS="LEFT TOP"  WIDTH=92><A HREF="#sub:rawbytes"><IMG  ALT="[*]" SRC="crossref.png"></A></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92>depth</TD>
<TD CLASS="LEFT TOP"  WIDTH=92><A HREF="#sub:depth"><IMG  ALT="[*]" SRC="crossref.png"></A></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92>offset</TD>
<TD CLASS="LEFT TOP"  WIDTH=92><A HREF="#sub:offset"><IMG  ALT="[*]" SRC="crossref.png"></A></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92>distance</TD>
<TD CLASS="LEFT TOP"  WIDTH=92><A HREF="#sub:Distance"><IMG  ALT="[*]" SRC="crossref.png"></A></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92>within</TD>
<TD CLASS="LEFT TOP"  WIDTH=92><A HREF="#sub:Within"><IMG  ALT="[*]" SRC="crossref.png"></A></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92>http_client_body</TD>
<TD CLASS="LEFT TOP"  WIDTH=92><A HREF="#sub:HttpClientBody"><IMG  ALT="[*]" SRC="crossref.png"></A></TD>
</TR>
<TR><TD CLASS="LEFT TOP"  WIDTH=92>http_uri</TD>
<TD CLASS="LEFT TOP"  WIDTH=92><A HREF="#sub:HttpUri"><IMG  ALT="[*]" SRC="crossref.png"></A></TD>
</TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION00452000000000000000"></A><A ID="sub:nocase"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN> nocase
</H2>

<P>
The nocase keyword allows the rule writer to specify that the Snort should look
for the specific pattern, ignoring case.  nocase modifies the previous 'content' keyword in the rule.

<P>

<H3><A ID="SECTION00452100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
nocase;
</PRE>

<P>

<H3><A ID="SECTION00452200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">2</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</H3>

<DIV class="CENTER"><A ID="content_nocase_mod_example"></A><A ID="3285"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
Content rule with nocase modifier</CAPTION>
<TR><TD><IMG
 STYLE="height: 6.30ex; " SRC="img52.svg"
 ALT="\begin{figure}\begin{verbatim}alert tcp any any -&gt; any 21 (msg:''FTP ROOT''; content:''USER root''; nocase;)\end{verbatim}
\par\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION00453000000000000000"></A><A ID="sub:rawbytes"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN> rawbytes 
</H2>

<P>
The rawbytes keyword allows rules to look at the raw packet data, ignoring any
decoding that was done by preprocessors.  This acts as a modifier to the
previous content <A HREF="#sub:content"><IMG  ALT="[*]" SRC="crossref.png"></A> option. 

<P>

<H3><A ID="SECTION00453100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">1</SPAN> format</A>
</H3>

<P>
<PRE>
rawbytes;
</PRE>

<P>

<H3><A ID="SECTION00453200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</H3>

<P>
This example tells the content pattern matcher to look at the raw traffic,
instead of the decoded traffic provided by the Telnet decoder.
<PRE>
alert tcp any any -&gt; any 21 (msg: "Telnet NOP"; content: "|FF F1|"; rawbytes;)
</PRE>

<P>

<H2><A ID="SECTION00454000000000000000"></A><A ID="sub:depth"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN> depth
</H2>

<P>
The depth keyword allows the rule writer to specify how far into a packet Snort
should search for the specified pattern.  depth modifies the previous `content'
keyword in the rule.

<P>
A depth of 5 would tell Snort to only look look for the specified pattern
within the first 5 bytes of the payload.

<P>
As the depth keyword is a modifier to the previous `content' keyword, there
must be a content in the rule before `depth' is specified.

<P>
See Figure <A HREF="#combined_rule_with_offset_and_depth"><IMG  ALT="[*]" SRC="crossref.png"></A> for an example of a
combined content, offset, and depth search rule.

<P>

<H3><A ID="SECTION00454100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">4</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
depth: &lt;number&gt;;
</PRE>

<P>

<H2><A ID="SECTION00455000000000000000"></A><A ID="sub:offset"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN> offset
</H2>

<P>
The offset keyword allows the rule writer to specify where to start searching
for a pattern within a packet.  offset modifies the previous 'content' keyword
in the rule.

<P>
An offset of 5 would tell Snort to start looking for the specified pattern
after the first 5 bytes of the payload.

<P>
As this keyword is a modifier to the previous 'content' keyword, there must be
a content in the rule before 'offset' is specified.

<P>
See Figure <A HREF="#combined_rule_with_offset_and_depth"><IMG  ALT="[*]" SRC="crossref.png"></A> for an example of a
combined content, offset, and depth search rule.

<P>

<H3><A ID="SECTION00455100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
offset: &lt;number&gt;;
</PRE>

<P>

<DIV class="CENTER"><A ID="combined_rule_with_offset_and_depth"></A><A ID="3289"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
Combined Content, Offset
and Depth Rule. Skip the first 4 bytes, and look for cgi-bin/phf in the next 20 bytes</CAPTION>
<TR><TD><IMG
 STYLE="height: 6.30ex; " SRC="img53.svg"
 ALT="\begin{figure}\begin{verbatim}alert tcp any any -&gt; any 80 (content: ''cgi-bin/phf''; offset:4; depth:20;)\end{verbatim}
\par\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION00456000000000000000"></A><A ID="sub:Distance"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN> distance
</H2>

<P>
The distance keyword allows the rule writer to specify how far into a packet
Snort should ignore before starting to search for the specified pattern
relative to the end of the previous pattern match.  

<P>
This can be thought of as exactly the same thing as depth (See Section
<A HREF="#sub:offset"><IMG  ALT="[*]" SRC="crossref.png"></A>), except it is relative to the end of the last pattern match
instead of the beginning of the packet.

<P>

<H3><A ID="SECTION00456100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
distance: &lt;byte count&gt;;
</PRE>

<P>

<H3><A ID="SECTION00456200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">6</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</H3>

<P>
The rule listed in Figure <A HREF="#fig:Distance"><IMG  ALT="[*]" SRC="crossref.png"></A> maps to a regular
expression of /ABCDE.{1}EFGH/.

<P>

<DIV class="CENTER"><A ID="fig:Distance"></A><A ID="3291"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
distance usage example</CAPTION>
<TR><TD><IMG
 STYLE="height: 6.30ex; " SRC="img54.svg"
 ALT="\begin{figure}\begin{verbatim}alert tcp any any -&gt; any any (content:''ABC''; content: ''DEF''; distance:1;)\end{verbatim}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION00457000000000000000"></A><A ID="sub:Within"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN> within
</H2>

<P>
The within keyword is a content modifier that makes sure that
at most N bytes are between pattern matches using the content keyword ( See
Section <A HREF="#sub:content"><IMG  ALT="[*]" SRC="crossref.png"></A> ).  It's designed to be used in conjunction
with the distance (Section <A HREF="#sub:Distance"><IMG  ALT="[*]" SRC="crossref.png"></A>) rule option.

<P>
The rule listed in Figure <A HREF="#fig:Within"><IMG  ALT="[*]" SRC="crossref.png"></A> constrains the search to not
go past 10 bytes past the ABCDE match. 

<P>

<H3><A ID="SECTION00457100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
within: &lt;byte count&gt;;
</PRE>

<P>

<H3><A ID="SECTION00457200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">7</SPAN>.<SPAN CLASS="arabic">2</SPAN> Examples</A>
</H3>

<P>

<DIV class="CENTER"><A ID="fig:Within"></A><A ID="3293"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
within usage example</CAPTION>
<TR><TD><IMG
 STYLE="height: 6.30ex; " SRC="img55.svg"
 ALT="\begin{figure}\begin{verbatim}alert tcp any any -&gt; any any (content:''ABC''; content: ''EFG''; within:10;)\end{verbatim}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION00458000000000000000"></A><A ID="sub:HttpClientBody"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN> http_client_body
</H2>

<P>
The http_client_body keyword is a content modifier that restricts
the search to the NORMALIZED body of an HTTP client request.

<P>
The rule listed in Figure <A HREF="#fig:HttpClientBody"><IMG  ALT="[*]" SRC="crossref.png"></A> constrains the
search for the pattern "EFG" to the NORMALIZED body of an HTTP client request.

<P>
As this keyword is a modifier to the previous 'content' keyword, there must be
a content in the rule before 'http_client_body' is specified.

<P>

<H3><A ID="SECTION00458100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
http_client_body;
</PRE>

<P>

<H3><A ID="SECTION00458200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">8</SPAN>.<SPAN CLASS="arabic">2</SPAN> Examples</A>
</H3>

<P>

<DIV class="CENTER"><A ID="fig:HttpClientBody"></A><A ID="3295"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
http_client_body usage example</CAPTION>
<TR><TD><IMG
 STYLE="height: 6.30ex; " SRC="img56.svg"
 ALT="\begin{figure}\begin{verbatim}alert tcp any any -&gt; any 80 (content:''ABC''; content: ''EFG''; http_client_body;)\end{verbatim}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

        
        <p><table border="1"><tr><td><b>
        Note:&nbsp;&nbsp;</b>
The <SPAN  CLASS="texttt">http_client_body</SPAN> modifier is not allowed to be used with
the <SPAN  CLASS="texttt">rawbytes</SPAN> modifier for the same content.
        
        </b></td></tr></table></p>

<P>

<H2><A ID="SECTION00459000000000000000"></A><A ID="sub:HttpUri"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN> http_uri
</H2>

<P>
The http_uri keyword is a content modifier that restricts
the search to the NORMALIZED request URI field .  Using a
content rule option followed by a http_uri modifier is the
same as using a uricontent by itself (see: <A HREF="#sub:UriContent"><IMG  ALT="[*]" SRC="crossref.png"></A>).

<P>
The rule listed in Figure <A HREF="#fig:HttpUri"><IMG  ALT="[*]" SRC="crossref.png"></A> constrains the
search for the pattern "EFG" to the NORMALIZED URI.

<P>
As this keyword is a modifier to the previous 'content' keyword, there must be
a content in the rule before 'http_uri' is specified.

<P>

<H3><A ID="SECTION00459100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
http_uri;
</PRE>

<P>

<H3><A ID="SECTION00459200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">9</SPAN>.<SPAN CLASS="arabic">2</SPAN> Examples</A>
</H3>

<P>

<DIV class="CENTER"><A ID="fig:HttpUri"></A><A ID="3297"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
http_uri usage example</CAPTION>
<TR><TD><IMG
 STYLE="height: 6.30ex; " SRC="img57.svg"
 ALT="\begin{figure}\begin{verbatim}alert tcp any any -&gt; any 80 (content:''ABC''; content: ''EFG''; http_uri;)\end{verbatim}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

        
        <p><table border="1"><tr><td><b>
        Note:&nbsp;&nbsp;</b>
The <SPAN  CLASS="texttt">http_uri</SPAN> modifier is not allowed to be used with
the <SPAN  CLASS="texttt">rawbytes</SPAN> modifier for the same content.
        
        </b></td></tr></table></p>

<P>

<H2><A ID="SECTION004510000000000000000"></A><A ID="sub:UriContent"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN> uricontent
</H2>

<P>
The <SPAN  CLASS="texttt">uricontent</SPAN> keyword in the Snort rule language searches the
NORMALIZED request URI field.  This means that if you are writing
rules that include things that are normalized, such as %2f or directory
traversals, these rules will not alert.  The reason is that the things you
are looking for are normalized out of the URI buffer.  

<P>
For example, the URI: 
<PRE>/scripts/..%c0%af../winnt/system32/cmd.exe?/c+ver\end{verbatim}
will get normalized into:
\begin{verbatim}/winnt/system32/cmd.exe?/c+ver
</PRE>

<P>
Another example, the URI:
<PRE> /cgi-bin/aaaaaaaaaaaaaaaaaaaaaaaaaa/..%252fp%68f? \end{verbatim}
will get normalized into:
\begin{verbatim}/cgi-bin/phf?
</PRE>

<P>
When writing a <SPAN  CLASS="texttt">uricontent</SPAN> rule, write the content that you want to
find in the context that the URI will be normalized.  For example, if Snort
normalizes directory traversals, do not include directory traversals.  

<P>
You can write rules that look for the non-normalized content by using the
content option.  (See Section <A HREF="#sub:content"><IMG  ALT="[*]" SRC="crossref.png"></A>)

<P>
For a description of the parameters to this function, see the content rule
options in Section <A HREF="#sub:content"><IMG  ALT="[*]" SRC="crossref.png"></A>. 

<P>
This option works in conjunction with the HTTP Inspect preprocessor specified
in Section <A HREF="node11.html#sub:http-inspect"><IMG  ALT="[*]" SRC="crossref.png"></A>.

<P>

<H3><A ID="SECTION004510100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">10</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
uricontent:[!]&lt;content string&gt;;
</PRE>

<P>

        
        <p><table border="1"><tr><td><b>
        Note:&nbsp;&nbsp;</b>
<SPAN  CLASS="texttt">uricontent</SPAN> cannot be modified by a <SPAN  CLASS="texttt">rawbytes</SPAN> modifier.
        
        </b></td></tr></table></p>

<P>

<H2><A ID="SECTION004511000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN> urilen</A>
</H2>

<P>
The <SPAN  CLASS="texttt">urilen</SPAN> keyword in the Snort rule language specifies the exact length,
the minimum length, the maximum length, or range of URI lengths to match.  

<P>

<H3><A ID="SECTION004511100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">11</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
urilen: int&lt;&gt;int;
urilen: [&lt;,&gt;] &lt;int&gt;;
</PRE>

<P>
The following example will match URIs that are 5 bytes long:

<P>
<PRE>urilen: 5
</PRE>

<P>
The following example will match URIs that are shorter than 5 bytes:

<P>
<PRE>urilen: &lt; 5
</PRE>

<P>
The following example will match URIs that are greater than 5 bytes and less than 10 bytes:

<P>
<PRE>urilen: 5&lt;&gt;10
</PRE>

<P>
This option works in conjunction with the HTTP Inspect preprocessor specified
in Section <A HREF="node11.html#sub:http-inspect"><IMG  ALT="[*]" SRC="crossref.png"></A>.

<P>

<H2><A ID="SECTION004512000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN> isdataat</A>
</H2>

<P>
Verify that the payload has data at a specified location, optionally looking for data relative to the end of the previous content match.

<P>

<H3><A ID="SECTION004512100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
isdataat:&lt;int&gt;[,relative];
</PRE>

<P>

<H3><A ID="SECTION004512200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">12</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</H3>
<PRE>
alert tcp any any -&gt; any 111 (content:"PASS"; isdataat:50,relative; \ 
   content:!"|0a|"; distance:0;)
</PRE>
This rule looks for the string PASS exists in the packet, then verifies there
is at least 50 bytes after the end of the string PASS, then verifies that there
is not a newline character within 50 bytes of the end of the PASS string.

<P>

<H2><A ID="SECTION004513000000000000000"></A><A ID="pcre"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN> pcre 
</H2>
The pcre keyword allows rules to be written using perl compatible regular expressions.   
For more detail on what can be done via a pcre regular expression, check out the PCRE web site http://www.pcre.org

<P>

<H3><A ID="SECTION004513100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>
<PRE>
pcre:[!]"(/&lt;regex&gt;/|m&lt;delim&gt;&lt;regex&gt;&lt;delim&gt;)[ismxAEGRUB]";
</PRE>
The post-re modifiers set compile time flags for the regular expression.

<P>
<A ID="2192"></A>
<TABLE class="PAD  BORDER" style="">
<CAPTION><STRONG>Table:</STRONG>
Perl compatible modifiers</CAPTION>
<TR><TD CLASS="CENTER">i</TD>
<TD CLASS="LEFT TOP"  WIDTH=323>case insensitive</TD>
</TR>
<TR><TD CLASS="CENTER">s</TD>
<TD CLASS="LEFT TOP"  WIDTH=323>include newlines in the dot metacharacter</TD>
</TR>
<TR><TD CLASS="CENTER">m</TD>
<TD CLASS="LEFT TOP"  WIDTH=323>By default, the string is treated as one big line of characters.    and $ match at the beginning and ending of the string. When m is set,   and $  match immediately following or immediately before any newline in the buffer, as well as the very start and very end of the buffer.</TD>
</TR>
<TR><TD CLASS="CENTER">x</TD>
<TD CLASS="LEFT TOP"  WIDTH=323>whitespace  data characters in the pattern are ignored except when escaped or inside a character class</TD>
</TR>
</TABLE>

<P>
<A ID="2196"></A>
<TABLE class="PAD  BORDER" style="">
<CAPTION><STRONG>Table:</STRONG>
PCRE compatible modifiers</CAPTION>
<TR><TD CLASS="CENTER">A</TD>
<TD CLASS="LEFT TOP"  WIDTH=323>the pattern must match only at the start of the buffer (same as   )</TD>
</TR>
<TR><TD CLASS="CENTER">E</TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Set $ to match only at the end of the subject string.  Without E, $ also matches immediately before the final character if it is a newline (but not before any other newlines).</TD>
</TR>
<TR><TD CLASS="CENTER">G</TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Inverts the "greediness" of the quantifiers so that they are not greedy by default, but become greedy if followed by "?".</TD>
</TR>
</TABLE>

<P>
<A ID="2200"></A>
<TABLE class="PAD  BORDER" style="">
<CAPTION><STRONG>Table:</STRONG>
Snort specific modifiers</CAPTION>
<TR><TD CLASS="CENTER">R</TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Match relative to the end of the last pattern match.  (Similar to distance:0;)</TD>
</TR>
<TR><TD CLASS="CENTER">U</TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Match the decoded URI buffers (Similar to <SPAN  CLASS="texttt">uricontent</SPAN>)</TD>
</TR>
<TR><TD CLASS="CENTER">P</TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Match normalized HTTP request body (Similar to <SPAN  CLASS="texttt">uricontent</SPAN>)</TD>
</TR>
<TR><TD CLASS="CENTER">B</TD>
<TD CLASS="LEFT TOP"  WIDTH=323>Do not use the decoded buffers (Similar to rawbytes)</TD>
</TR>
</TABLE>

<P>
The modifiers R and B should not be used together.

<P>

<H3><A ID="SECTION004513200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">13</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</H3>

<P>
This example performs a case-insensitive search for the string BLAH in the payload.

<P>
<PRE>
alert ip any any -&gt; any any (pcre:"/BLAH/i";)
</PRE>

<P>

        
        <p><table border="1"><tr><td><b>
        Note:&nbsp;&nbsp;</b>
Snort's handling of multiple URIs with PCRE does not work as expected.  PCRE when used without a <SPAN  CLASS="texttt">uricontent</SPAN> only evaluates the first URI.  In order to use pcre to inspect all URIs, you must use either a content or a uricontent.
        
        </b></td></tr></table></p>

<P>

<H2><A ID="SECTION004514000000000000000"></A><A ID="sub:byte_test"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN> byte_test
</H2>

<P>
Test a byte field against a specific value (with operator).  Capable
 of testing binary values or converting representative byte strings to
their binary equivalent and testing them.

<P>
For a more detailed explanation, please read Section <A HREF="node27.html#testing_numerical_values"><IMG  ALT="[*]" SRC="crossref.png"></A>.

<P>

<H3><A ID="SECTION004514100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">14</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
byte_test: &lt;bytes to convert&gt;, [!]&lt;operator&gt;, &lt;value&gt;, &lt;offset&gt;  \
    [,relative] [,&lt;endian&gt;] [,&lt;number type&gt;, string];
</PRE>

<P>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT"><B>Option</B></TD>
<TD CLASS="LEFT"><B>Description</B></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">bytes_to_convert</SPAN></TD>
<TD CLASS="LEFT">Number of bytes to pick up from the packet</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">operator</SPAN></TD>
<TD CLASS="LEFT">Operation to perform to test the value:

<UL>
<LI><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.21ex; " SRC="img1.svg"
 ALT="$&lt;$"></SPAN> - less than
</LI>
<LI><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.21ex; " SRC="img2.svg"
 ALT="$&gt;$"></SPAN> - greater than
</LI>
<LI>= - equal
</LI>
<LI>! - not
</LI>
<LI>&amp; - bitwise AND
</LI>
<LI>  bitwise OR
</LI>
</UL></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">value</SPAN></TD>
<TD CLASS="LEFT">Value to test the converted value against</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">offset</SPAN></TD>
<TD CLASS="LEFT">Number of bytes into the payload to start processing</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">relative</SPAN></TD>
<TD CLASS="LEFT">Use an offset relative to last pattern match</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">endian</SPAN></TD>
<TD CLASS="LEFT">Endian type of the number being read: 

<UL>
<LI><SPAN  CLASS="texttt">big</SPAN> - Process data as big endian (default)
</LI>
<LI><SPAN  CLASS="texttt">little</SPAN> - Process data as little endian
</LI>
</UL></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">string</SPAN></TD>
<TD CLASS="LEFT">Data is stored in string format in packet</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">number type</SPAN></TD>
<TD CLASS="LEFT">Type of number being read:

<UL>
<LI><SPAN  CLASS="texttt">hex</SPAN> - Converted string data is represented in hexadecimal
</LI>
<LI><SPAN  CLASS="texttt">dec</SPAN> - Converted string data is represented in decimal
</LI>
<LI><SPAN  CLASS="texttt">oct</SPAN> - Converted string data is represented in octal
</LI>
</UL></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
</TABLE>

<P>
Any of the operators can also include <SPAN  CLASS="textit">!</SPAN> to check if the operator is not true.  
If <SPAN  CLASS="textit">!</SPAN> is specified without an operator, then the operator is set to <SPAN  CLASS="textit">=</SPAN>.

<P>

        
        <p><table border="1"><tr><td><b>
        Note:&nbsp;&nbsp;</b>
Snort uses the C operators for each of these operators.  If the <SPAN  CLASS="textit">&amp;</SPAN> operator is used, 
then it would be the same as using <SPAN  CLASS="textit">if (data &amp; value) { do_something();} </SPAN>
        
        </b></td></tr></table></p>

<P>

<DIV class="CENTER"><A ID="fig:byte_test"></A><A ID="3305"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
Byte Test Usage Example</CAPTION>
<TR><TD><IMG
 STYLE="height: 89.60ex; " SRC="img58.svg"
 ALT="\begin{figure}\begin{verbatim}alert udp $EXTERNAL_NET any -&gt; $HOME_NET any \
...
...deadbeef, 0, string, hex; \
msg: ''got DEADBEEF!'';)\end{verbatim}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION004515000000000000000"></A><A ID="sub:byte_jump"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN> byte_jump
</H2>

<P>
The <SPAN  CLASS="texttt">byte_jump</SPAN> keyword allows rules to be written for length encoded protocols 
trivially. By having an option that reads the length of a portion of data,
then skips that far forward in the packet, rules can be written that skip
over specific portions of length-encoded protocols and perform detection in very specific locations.

<P>
The <SPAN  CLASS="texttt">byte_jump</SPAN> option does this by reading some number of bytes, convert them
to their numeric representation, move that many bytes forward and set a pointer
for later detection.  This pointer is known as the detect offset end pointer, or doe_ptr.

<P>
For a more detailed explanation, please read Section <A HREF="node27.html#testing_numerical_values"><IMG  ALT="[*]" SRC="crossref.png"></A>.

<P>

<H3><A ID="SECTION004515100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">15</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
byte_jump: &lt;bytes_to_convert&gt;, &lt;offset&gt; \
        [,relative] [,multiplier &lt;multiplier value&gt;] [,big] [,little][,string]\
        [,hex] [,dec] [,oct] [,align] [,from_beginning];
</PRE>

<P>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT"><B>Option</B></TD>
<TD CLASS="LEFT"><B>Description</B></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">bytes_to_convert</SPAN></TD>
<TD CLASS="LEFT">Number of bytes to pick up from the packet</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">offset</SPAN></TD>
<TD CLASS="LEFT">Number of bytes into the payload to start processing</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">relative</SPAN></TD>
<TD CLASS="LEFT">Use an offset relative to last pattern match</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">multiplier <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.21ex; " SRC="img1.svg"
 ALT="$&lt;$"></SPAN>value<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.21ex; " SRC="img2.svg"
 ALT="$&gt;$"></SPAN></SPAN></TD>
<TD CLASS="LEFT">Multiply the number of calculated bytes by
<SPAN  CLASS="texttt"><SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.21ex; " SRC="img1.svg"
 ALT="$&lt;$"></SPAN>value<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.21ex; " SRC="img2.svg"
 ALT="$&gt;$"></SPAN></SPAN> and skip forward that number of bytes.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">big</SPAN></TD>
<TD CLASS="LEFT">Process data as big endian (default)</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">little</SPAN></TD>
<TD CLASS="LEFT">Process data as little endian</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">string</SPAN></TD>
<TD CLASS="LEFT">Data is stored in string format in packet</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">hex</SPAN></TD>
<TD CLASS="LEFT">Converted string data is represented in hexadecimal</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">dec</SPAN></TD>
<TD CLASS="LEFT">Converted string data is represented in decimal</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">oct</SPAN></TD>
<TD CLASS="LEFT">Converted string data is represented in octal</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">align</SPAN></TD>
<TD CLASS="LEFT">Round the number of converted bytes up to the next 32-bit boundary</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">from_beginning</SPAN></TD>
<TD CLASS="LEFT">Skip forward from the beginning of the packet payload instead of from the
current position in the packet.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
</TABLE>

<P>

<DIV class="CENTER"><A ID="fig:byte_jump"></A><A ID="3308"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure:</STRONG>
byte jump Usage Example</CAPTION>
<TR><TD><IMG
 STYLE="height: 17.41ex; " SRC="img59.svg"
 ALT="\begin{figure}\begin{verbatim}alert udp any any -&gt; any 32770:34000 (content: '...
...ve; \
msg: ''statd format string buffer overflow'';)\end{verbatim}
\end{figure}"></TD></TR>
</TABLE>
</DIV>

<P>

<H2><A ID="SECTION004516000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN> ftpbounce</A>
</H2>

<P>
The ftpbounce keyword detects FTP bounce attacks.

<P>

<H3><A ID="SECTION004516100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
	ftpbounce;
</PRE>

<P>

<H3><A ID="SECTION004516200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">16</SPAN>.<SPAN CLASS="arabic">2</SPAN> Example</A>
</H3>
<PRE>
alert tcp $EXTERNAL_NET any -&gt; $HOME_NET 21 (msg:"FTP PORT bounce attempt"; \
flow:to_server,established; content:"PORT"; nocase; ftpbounce; pcre:"/^PORT/smi";\
classtype:misc-attack; sid:3441; rev:1;)
</PRE>

<P>

<H2><A ID="SECTION004517000000000000000"></A><A ID="asn1"></A>
<BR>
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN> asn1
</H2>

<P>
The ASN.1 detection plugin decodes a packet or a portion of a packet, and looks
for various malicious encodings.

<P>
Multiple options can be used in an 'asn1' option and the implied logic is
boolean OR.  So if any of the arguments evaluate as true, the whole option
evaluates as true.

<P>
The ASN.1 options provide programmatic detection capabilities as well as some
more dynamic type detection.  If an option has an argument, the option and the
argument are separated by a space or a comma.  The preferred usage is to use a
space between option and argument.

<P>

<H3><A ID="SECTION004517100000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">1</SPAN> Format</A>
</H3>

<P>
<PRE>
asn1: option[ argument][, option[ argument]] . . .
</PRE>

<P>
<TABLE class="PAD  BORDER" style="">
<TR><TD CLASS="LEFT"><B>Option</B></TD>
<TD CLASS="LEFT"><B>Description</B></TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">bitstring_overflow</SPAN></TD>
<TD CLASS="LEFT">Detects invalid bitstring encodings that are known to be remotely exploitable.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">double_overflow</SPAN></TD>
<TD CLASS="LEFT">Detects a double ASCII encoding that is larger than a standard buffer.  This is known to be an exploitable function in Microsoft, but it is unknown at this time which services may be exploitable.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">oversize_length <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.21ex; " SRC="img1.svg"
 ALT="$&lt;$"></SPAN>value<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.21ex; " SRC="img2.svg"
 ALT="$&gt;$"></SPAN></SPAN></TD>
<TD CLASS="LEFT">Compares ASN.1 type lengths with the supplied argument.  The syntax looks like, &ldquo;oversize_length 500&rdquo;.  This means that if an ASN.1 type is greater than 500, then this keyword is evaluated as true.  This keyword must have one argument which specifies the length to compare against.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">absolute_offset <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.21ex; " SRC="img1.svg"
 ALT="$&lt;$"></SPAN>value<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.21ex; " SRC="img2.svg"
 ALT="$&gt;$"></SPAN></SPAN></TD>
<TD CLASS="LEFT">This is the absolute offset from the beginning of the packet.  For example, if you wanted to decode snmp packets, you would say &ldquo;absolute_offset 0&rdquo;.  <SPAN  CLASS="texttt">absolute_offset</SPAN> has one argument, the offset value.  Offset may be positive or negative.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">relative_offset <SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.21ex; " SRC="img1.svg"
 ALT="$&lt;$"></SPAN>value<SPAN CLASS="MATH"><IMG
 STYLE="height: 1.80ex; vertical-align: -0.21ex; " SRC="img2.svg"
 ALT="$&gt;$"></SPAN></SPAN></TD>
<TD CLASS="LEFT">This is the relative offset from the last content match or byte_test/jump.  <SPAN  CLASS="texttt">relative_offset</SPAN> has one argument, the offset number.  So if you wanted to start decoding and ASN.1 sequence right after the content &ldquo;foo&rdquo;, you would specify <code>'content:"foo"; asn1: bitstring_overflow, relative_offset 0'</code>.  Offset values may be positive or negative.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
</TABLE>

<P>

<H3><A ID="SECTION004517200000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">17</SPAN>.<SPAN CLASS="arabic">2</SPAN> Examples</A>
</H3>

<P>
<PRE>
alert udp any any -&gt; any 161 (msg:"Oversize SNMP Length"; \
    asn1: oversize_length 10000, absolute_offset 0;)
    
alert tcp any any -&gt; any 80 (msg:"ASN1 Relative Foo"; content:"foo"; \
    asn1: bitstring_overflow, relative_offset 0;)
</PRE>

<P>

<H2><A ID="SECTION004518000000000000000">
<SPAN CLASS="arabic">3</SPAN>.<SPAN CLASS="arabic">5</SPAN>.<SPAN CLASS="arabic">18</SPAN> Payload Detection Quick Reference</A>
</H2>
<DIV class="CENTER">
<A ID="2312"></A>
<TABLE class="PAD  BORDER" style="">
<CAPTION><STRONG>Table:</STRONG>
Payload detection rule option keywords</CAPTION>
<TR><TD CLASS="LEFT">Keyword</TD>
<TD CLASS="LEFT TOP"  WIDTH=92>Description</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">content</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=92>The content keyword allows the user to set rules that search for
specific content in the packet payload and trigger response based on that data.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">rawbytes</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=92>The rawbytes keyword allows rules to look at the raw packet data,
ignoring any decoding that was done by preprocessors.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">depth</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=92>The depth keyword allows the rule writer to specify how far into a
packet Snort should search for the specified pattern.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">offset</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=92>The offset keyword allows the rule writer to specify where to start
searching for a pattern within a packet.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">distance</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=92>The distance keyword allows the rule writer to specify how far
into a packet Snort should ignore before starting to search for the specified
pattern relative to the end of the previous pattern match.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">within</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=92>The within keyword is a content modifier that makes sure that at
most N bytes are between pattern matches using the content keyword.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">uricontent</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=92>The uricontent keyword in the Snort rule language searches the
normalized request URI field.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">isdataat</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=92>The isdataat keyword verifies that the payload has data at a
specified location.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">pcre</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=92>The pcre keyword allows rules to be written using perl compatible
regular expressions.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">byte_test</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=92>The byte_test keyword tests a byte field against a specific
value (with operator).</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">byte_jump</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=92>The byte_jump keyword allows rules to read the length of a
portion of data, then skip that far forward in the packet.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
<TR><TD CLASS="LEFT"><SPAN  CLASS="texttt">ftpbounce</SPAN></TD>
<TD CLASS="LEFT TOP"  WIDTH=92>The ftpbounce keyword detects FTP bounce attacks.</TD>
<TD CLASS="LEFT">&nbsp;</TD>
<TD CLASS="LEFT TOP"  WIDTH=461>&nbsp;</TD>
</TR>
</TABLE>
</DIV>

<P>

<DIV CLASS="navigation"><HR>
<!--Navigation Panel-->
<A
 HREF="node22.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node16.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node20.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html621"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node22.html">3.6 Non-Payload Detection Rule Options</A>
<B> Up:</B> <A
 HREF="node16.html">3. Writing Snort Rules: How</A>
<B> Previous:</B> <A
 HREF="node20.html">3.4 General Rule Options</A>
 &nbsp; <B>  <A ID="tex2html622"
  HREF="node1.html">Contents</A></B> </DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
